
红黑数原理分析

	通过整个的二叉树的实现相信已经可以清楚二叉树的主要特点：数据查询的时候可以提供更好的查询性能，但是
这种原始的二叉树结构是由明显缺陷的，例如：当二叉树结构改变的时候（增加或删除）就有可能出现不平衡的问题。



	之前所谓的解决二叉树性能问题的方式最终全部都变为了null，也就是说如果要想达到最良好效果的二叉树，
那么他首先因该是一个平衡二叉树，同时所有的节点的层次深度应该相同。

	如果所有的数据按照以上的结构进行保存，那么二叉树的检索执行效率一定是最高的，可是你的树需要可以忍受着些
频繁的增加或者是删除操作。所以针对于二叉树有了进一步的设计要求：


红黑树：
	红黑数本质上是一种二叉树，但是它在二叉查找树的基础额外添加了一个标记（颜色，boolean），同时具有一些规则
。这些规则使红黑数保证了一种平衡，插入删除，查找的最坏时间复杂度都为O（longn）.
	红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树。后来，在1978年被Len J.Guibas和Robert Sedgewick
修改为先如今的“红黑树”


	红黑数的本质就是在节点上追加了一个表示颜色操作信息而已。
enum Color{
	RED,BLACK;
}
class BinaryTree<T>{
	private class Node{
		private T data;
		private Node parent;
		private Node left;
		private Node right;
		private Color color;
	}
}

	对于Node节点中的颜色标记也可以使用true或false来实现，不一定非要使用枚举类。一个标准的红黑树的结构如下所示。


红黑数特点：

	1、每个节点或者是黑色，或者是红色；
	2、根节点必须是黑色；
	3、每个叶子节点也是黑色
		java实现的红黑数将使用null来表示空节点，因此遍历红黑数时将看不到
		黑色的叶子节点，反而看到每个叶子节点都是红色
	4、如果一个节点是红色的，则它的子节点必须是黑色的；
		从每个根到节点的路径上不会有两个连续的红色节点，但是黑色节点是可以
		连续的。若给定黑色节点的个数N，最短路径情况是连续的N个黑色，树的
		高度为N-1；最长路径的情况为节点红黑相间，树的高度为2（N-1）；
	5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点数量；
		成为红黑数最主要的条件，后续的插入、删除操作都是为了遵守这个规定



	红色节点之后绝对不可能是红色节点，但是没有说黑色节点之后不允许是黑色节点，允许黑――黑连接，
	
	主要是利用这个红色节点与黑色节点实现均衡的控制。简单点理解红黑数的结构就是为了可以进行左旋
和右旋的控制以保证树的平衡性。



	但是对于平衡性，还需要考虑数据增加的平衡以及数据删除的平衡，增加和删除都是需要对这棵树进行平衡修复。

数据插入平衡修复：

	1、第一次插入，由于原树为空，所以只会违反红-黑树的规则二，所以只要把根节点涂黑即可；

	2、如果插入节点的父节点是黑色的，那么不会违背红-黑树的规则，什么也不需要做；但是
	遇到如下的三种情况时，就要开始变色和旋转了：
		（1）插入节点的父节点和其叔叔节点均为红色的；
			将当前节点的父节点与叔叔节点涂黑；祖父节点涂红
		（2）插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点；
			将新增节点的父节点与祖父节点进行颜色互换随后采用以当前节点的父节点为轴做右旋处理；
		（3）插入节点的父节点是红色，叔叔节点是黑色，且插入节点使其父节点的右子节点；
			将新增节点与父节点进行左旋处理将新节点变为左节点，随后参考规则二


	在进行红黑数处理的时候为了方便操作都会将新的节点使用红色来进行描述，于是当设置根节点的时候就会违反“规则2”
那么这个时候只需要将节点的颜色涂黑即可。


	在红黑进行修复处理之中，他需要根据当前节点以及当前节点的父节点和叔叔节点之间的颜色来推断树是否需要进行处理。



数据删除平衡修复：


	1、删除操作后，如果当前节点是黑色的根节点，那么不用任何操作，因为并没有破坏树的平衡性，即没有违背红-黑数
	的规则
	2、如果当前节点是红色的，说明刚刚移走的后继节点是黑色的，那么不管后继节点的父节点是啥颜色，只要将当前节点
	涂黑就可以可，红-黑的平衡性就可以恢复。
	3、但是如果遇到一下四种情况就需要通过变色或者旋转来回复红黑树的平衡了：
		（1）当前节点是黑色的，且兄弟节点是红色的（那么父节点和兄弟节点的子节点肯定是黑的）；
			・当前节点是删除后重新保存的节点信息；
			・将当前节点的父节点涂红，将兄弟节点涂黑，然后将当前节点的父节点作为左旋指点；
		（2）当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的两个子节点均为黑色的；
			・将当前节点的而兄弟节点涂红，将当前节点指向其父节点，将当前节点的父节点指向其祖父节点，不旋转；
		（3）当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点是黑色的
			・将当前节点的兄弟节点涂红，把兄弟节点的左子节点涂黑，然后以兄弟节点作为支点进行右旋；

		（4）当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的右子节点是红色，左子节点任意颜色
			
			・将当前节点的兄弟节点涂成与父节点相同的颜色，再把父节点涂成黑色，把兄弟节点的右子节点
			涂黑，然后以当前节点的父节点为支点进行左旋。

		在红黑数之中修复的目的是为了保证树结构中的黑色节点的数量平衡，，黑色节点的数量平衡了，那么才可能得到“O（logn）”
	的执行性能，但是修复的过程一方面是红黑的粗粒，另一方面就是黑色子节点的保存的层次。
























































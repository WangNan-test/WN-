

	Spring种针对于业务层与数据层之间的调用事务的处理操作，提供有一个事务的传播属性，简单的理解就是业务层
是否可以继续在数据层起效。所有的传播属性都在“ TransactionDefinition”接口种利用常量进行了定义，一共有如下的几种
传播属性。

		传播属性				数值		描述
		PROPAGATION_REQUIRED		0		表示一定要存在有事务的处理，如果现在没有事务那么将自动创建一个新的事物，这种配置是在开发使用的最多的形式
		PROPAGATION_SUPPORTS		1		如果现在有事物则直接使用当前的事物进行处理，如果没有事物则采用非事务的方式继续执行。
		PROPAGATION_MANDATORY	2		如果说现在已经开启了事务，则继续使用当前的事务，如果没有存在事务则抛出相关的异常。
		PROPAGATION_REQUIRES_NEW	3		总是会开启新的事物，如果已经有事物存在，则先将原始事物挂起
		PROPAGATION_NOT_SUPPORTED	4		总是以非实物的方式运行，并且总是会挂起已有的事务
		PROPAGATION_NEVER		5		以非事物的方式运行，如果存在有事物则抛出异常
		PROPAGATION_NESTED		6		如果存在有一个活跃的事务，则会自动二点开启一个新的事物并且运行在当前事物之中，如果没有事物，则会按照“PROPAGATION_REQUIRED”处理

	下面为了方便大家理解以上的事物传播属性，将通过一些伪代码的形式对这些事务的操作进行一些简短的描述。

1、PROPAGATION_REQUIRED，此种事务的传播属性是在醒目开发之中使用最多的，他的操作本质在于如果现在没有开启事务，则会自动的进行一个新事务的开启，即保证整个
的操作过程之中永远存在一个活跃的事务

业务操作调用：

	【S】业务操作方法A(){	//业务操作方法里面一定要进行数据曾操作
		{Transaction}在业务层里面已经开启了事务
		【D】数据方法B();
	}
JDBC的处理操作。
	【D】数据方法B(){
		由于业务层已经开启了事务，所以此处直接进行JDBC的核心操作计科	
		此处不负责进行事务的开启、提交、回滚等操作。
	}

	·情况二：如果业务层没有进行事务的开启操作，则数据层将自己开启一个新的事物；

	【S】业务操作方法A(){	//业务操作方法里面一定要进行数据曾操作
		{Transaction}没有进行事物的开启
		【D】数据方法B();
	}
	【D】数据方法B(){
		connection.setAutoCommit(false)//取消自动提交事务
		try{
			pstmt.executeUpdate()	//继续数据库的根性操作
			connection.commit();	//事务提交
		}catch(Exception e){
			connection.roolback();	//事务回滚	
		}
	}
	对于以上的事务的传播属性，实际上如果从开发的角度来讲重点理解“PROPAGATION_REQUIRED”的
操作流程即可。


















